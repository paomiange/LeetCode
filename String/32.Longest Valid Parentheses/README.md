求最长的合法括号组合。

根据动态规划（DP）来解决：

新建dp数组：

* dp[i]：以s[i]开头的最长的括号组合有多长
* dp[i]:
  * if  (s[i] == ' ) ')以闭括号开头，dp[i]=0
  * if  (s[i] == ' ( ')以开括号开头
    * dp[i+1]代表下一个元素开头的最大长度，```nextIndex=i+1+dp[i+1]```求得的值就是当前s[i]越过最长的一串括号组合的下一个元素，如果是闭括号，那正好在当前的长度上加2，如果是开括号，那说明形不成括号组合，长度为0。
    * 比如s[i+1]也是开括号，dp[i+1]=4，那么我们越过这四个元素如果找到了一个闭括号，dp[i]就为dp[i+1]+2=6。如果s[i+1]是闭括号，那么dp[i+1]肯定为0，nextIndex的值为i+1，我们得到的dp[i]=2。
    * 除此之外我们要考虑的一种情况是，在闭括号和我们当前的开括号闭合的情况下，之后的元素也可能是一个连续的括号组合，如```((()))()()```，所以还要再加上dp[nextIndex+1]。